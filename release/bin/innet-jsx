#!/usr/bin/env node
'use strict';

var MagicString = require('magic-string');
var acorn = require('acorn');
var fs = require('node:fs');
var commander = require('commander');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var MagicString__default = /*#__PURE__*/_interopDefaultLegacy(MagicString);
var fs__default = /*#__PURE__*/_interopDefaultLegacy(fs);

const { extend } = require('acorn-jsx-walk');
const { base, simple } = require('acorn-walk');
const jsxParser = require('acorn-jsx');
const merge = require('merge-source-map');
const JSXParser = acorn.Parser.extend(jsxParser());
extend(base);
function parse(code, options) {
    return JSXParser.parse(code, Object.assign({ ecmaVersion: 'latest' }, options));
}
const BASE64_SOURCEMAP_STARTS_WITH = '//# sourceMappingURL=data:application/json;charset=utf-8;base64,';
const base64ToMap = typeof Buffer === 'undefined'
    ? value => btoa(value)
    : value => Buffer.from(value, 'base64').toString();
function normaliseInput(code, map) {
    const inlineSourceMapIndex = code.lastIndexOf('\n') + 1;
    const lastString = code.slice(inlineSourceMapIndex);
    if (lastString.startsWith(BASE64_SOURCEMAP_STARTS_WITH)) {
        code = code.slice(0, inlineSourceMapIndex);
        if (!map) {
            map = JSON.parse(base64ToMap(lastString.slice(BASE64_SOURCEMAP_STARTS_WITH.length)));
        }
    }
    return {
        code,
        map
    };
}
function transform(code, { map, jsxFile, jsFile, parser = parse } = {}) {
    if (typeof code === 'object') {
        map = map || code.map;
        code = code.code;
    }
    const jsxData = normaliseInput(code, map);
    const magicString = new MagicString__default["default"](jsxData.code);
    let ast;
    try {
        ast = parser(code);
    }
    catch (err) {
        err.message += ` in file://${jsxFile}`;
        throw err;
    }
    simple(ast, {
        JSXText(data) {
            const { start, end, raw } = data;
            if (raw) {
                const keepRightSpace = jsxData.code[end] === '{';
                const keepLeftSpace = jsxData.code[start - 1] === '}';
                let targetValue = raw
                    .replace(/('|\\)/g, "\\$1")
                    .replace(/\n/g, '')
                    .replace(/(\s)+/g, ' ');
                if (!keepLeftSpace) {
                    targetValue = targetValue.replace(/^(\s)+/g, '');
                }
                if (!keepRightSpace) {
                    targetValue = targetValue.replace(/(\s)+$/g, '');
                }
                data.result = targetValue;
                magicString.overwrite(start, end, targetValue ? `'${targetValue}'` : '');
            }
        },
        JSXExpressionContainer({ start, end }) {
            magicString.remove(start, start + 1);
            magicString.remove(end - 1, end);
        },
        JSXFragment({ children }) {
            let started = false;
            for (let i = 0; i < children.length; i++) {
                const { type, start, result } = children[i];
                if (type !== 'JSXText' || result) {
                    if (started) {
                        magicString.appendLeft(start, ',');
                    }
                    else {
                        started = true;
                    }
                }
            }
        },
        JSXOpeningFragment({ start, end }) {
            magicString.overwrite(start, end, '[');
        },
        JSXClosingFragment({ start, end }) {
            magicString.overwrite(start, end, ']');
        },
        JSXElement({ children, openingElement, end }) {
            const hasAttributes = Boolean(openingElement.attributes.filter(({ name }) => (name === null || name === void 0 ? void 0 : name.name) !== 'children').length);
            const addArray = children.filter(node => {
                if (node.type === 'JSXText' && !node.result)
                    return false;
                return true;
            }).length > 1 || children.some(node => node.type === 'JSXExpressionContainer' && node.expression.type === 'JSXEmptyExpression');
            const childrenStartSymbol = addArray ? '[' : '';
            const childrenEndSymbol = addArray ? ']' : '';
            let childrenStarted = false;
            let lastEnd;
            for (let i = 0; i < children.length; i++) {
                const { type, start, end, result } = children[i];
                lastEnd = end;
                if (type !== 'JSXText' || result) {
                    if (!childrenStarted) {
                        if (hasAttributes) {
                            const propsEnd = openingElement.attributes[openingElement.attributes.length - 1].end;
                            magicString.appendLeft(propsEnd, `,children:${childrenStartSymbol}`);
                        }
                        else {
                            magicString.appendLeft(openingElement.end, `,props:{children:${childrenStartSymbol}`);
                        }
                        childrenStarted = true;
                    }
                    else {
                        magicString.appendLeft(start, ',');
                    }
                }
            }
            if (childrenStarted) {
                magicString.appendRight(lastEnd, `${childrenEndSymbol}}`);
            }
            else if (hasAttributes && !openingElement.selfClosing) {
                magicString.appendLeft(end, '}');
            }
        },
        JSXOpeningElement({ start, end, name, selfClosing, attributes }) {
            var _a, _b;
            const stringSym = name.type === 'JSXMemberExpression' || !/[a-z]/.test(((_a = name.name) === null || _a === void 0 ? void 0 : _a[0]) || '') ? '' : "'";
            magicString.overwrite(start, start + 1, '{type:');
            if (stringSym) {
                magicString.appendLeft(name.start, stringSym);
                magicString.appendLeft(name.end, stringSym);
            }
            const lastEnd = !(attributes === null || attributes === void 0 ? void 0 : attributes.length) ? name.end : attributes[attributes.length - 1].end;
            if (selfClosing) {
                magicString.overwrite(lastEnd, end, `}`);
            }
            else {
                magicString.remove(lastEnd, end);
            }
            if (attributes) {
                let lastEnd = name.end;
                for (let i = 0; i < attributes.length; i++) {
                    const attribute = attributes[i];
                    magicString.remove(lastEnd, attribute.start);
                    lastEnd = attribute.end;
                    if (!selfClosing && ((_b = attribute.name) === null || _b === void 0 ? void 0 : _b.name) === 'children') {
                        magicString.remove(attribute.start, attribute.end);
                        continue;
                    }
                    if (!i) {
                        magicString.appendLeft(name.end, ',props:{');
                    }
                    else {
                        magicString.appendLeft(attribute.start - 1, ',');
                    }
                    if (i + 1 === attributes.length && selfClosing) {
                        magicString.appendRight(attribute.end, '}');
                    }
                }
            }
        },
        JSXClosingElement({ start, end }) {
            magicString.overwrite(start, end, `}`);
        },
        JSXAttribute({ name, value }) {
            const isNamespacedName = name.type === 'JSXNamespacedName';
            let namespacedNameType;
            if (isNamespacedName) {
                const { namespace } = name;
                name = name.name;
                namespacedNameType = namespace.name;
                magicString.overwrite(namespace.start, namespace.end + 1, '');
            }
            if (name.name.includes('-')) {
                magicString.overwrite(name.start, name.end, `'${name.name}'`);
            }
            if (value) {
                if (value.type !== 'Literal' && namespacedNameType === 'get') {
                    magicString.overwrite(name.end, value.start, `(){return `);
                    magicString.appendLeft(name.start, 'get ');
                    magicString.appendLeft(value.end, '}');
                }
                else {
                    magicString.overwrite(name.end, value.start, `:`);
                }
                if (value.type === 'Literal' && value.value) {
                    magicString.overwrite(value.start + 1, value.end - 1, value.value.replace(/\\/g, '\\\\'));
                }
            }
            else {
                magicString.appendLeft(name.end, ':true');
            }
        },
        JSXSpreadAttribute({ start, end }) {
            magicString.remove(start, start + 1);
            magicString.remove(end - 1, end);
        },
        ArrowFunctionExpression({ body }) {
            if ((body === null || body === void 0 ? void 0 : body.type) === 'JSXElement') {
                for (let i = body.start; i > 0; i--) {
                    if (jsxData.code[i] === '(')
                        return;
                    if (jsxData.code[i] === '>') {
                        magicString.appendLeft(body.start, '(');
                        magicString.appendRight(body.end, ')');
                        break;
                    }
                }
            }
        },
    });
    return {
        code: magicString.toString(),
        map: merge(jsxData.map, magicString.generateMap({
            file: jsFile,
            source: jsxFile,
            includeContent: true,
            hires: true
        }))
    };
}

(function () {
  const env = {"__INNETJS_JSX__PACKAGE_VERSION":"2.0.8"};
  if (typeof process === 'undefined') {
    globalThis.process = { env: env };
  } else if (process.env) {
    Object.assign(process.env, env);
  } else {
    process.env = env;
  }
})();
commander.program
    .version(process.env.__INNETJS_JSX__PACKAGE_VERSION, '-v, --version');
commander.program
    .arguments('<jsx-file> [js-file]')
    .description('Converts <jsx-file> to <js-file>', {
    'jsx-file': 'Target file path, you want convert',
    'js-file': 'A path of the converted file',
})
    .option('-m, --map', 'Create map file')
    .option('-w, --watch', 'Watching of changes')
    .action((jsxFile, jsFile = jsxFile.replace(/\.jsx$/, '.js'), { map, watch }) => {
    function convert() {
        const data = transform(fs__default["default"].readFileSync(jsxFile, 'utf8'), { jsFile, jsxFile });
        if (map) {
            fs__default["default"].writeFileSync(jsFile, data.code + `\n//# sourceMappingURL=${jsFile.replace(/^(.*\/)?([^\/]+)$/, '$2') + '.map'}`);
            fs__default["default"].writeFileSync(jsFile + '.map', JSON.stringify(data.map));
        }
        else {
            fs__default["default"].writeFileSync(jsFile, data.code);
        }
        console.log('Successful build');
    }
    convert();
    if (watch) {
        fs__default["default"].watchFile(jsxFile, convert);
    }
});
commander.program
    .parse(process.argv);
