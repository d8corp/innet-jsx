#!/usr/bin/env node
'use strict';

var MagicString = require('magic-string');
var acorn = require('acorn');
var fs = require('fs');
var commander = require('commander');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var MagicString__default = /*#__PURE__*/_interopDefaultLegacy(MagicString);
var fs__default = /*#__PURE__*/_interopDefaultLegacy(fs);

var extend = require('acorn-jsx-walk').extend;
var _a = require('acorn-walk'), base = _a.base, simple = _a.simple;
var jsxParser = require('acorn-jsx');
var merge = require('merge-source-map');
var JSXParser = acorn.Parser.extend(jsxParser());
extend(base);
function parse(code, options) {
    return JSXParser.parse(code, Object.assign({ ecmaVersion: 'latest' }, options));
}
var BASE64_SOURCEMAP_STARTS_WITH = '//# sourceMappingURL=data:application/json;charset=utf-8;base64,';
var base64ToMap = typeof btoa === 'undefined'
    ? function (value) { return Buffer.from(value, 'base64').toString(); }
    : function (value) { return btoa(value); };
function normaliseInput(code, map) {
    var inlineSourceMapIndex = code.lastIndexOf('\n') + 1;
    var lastString = code.slice(inlineSourceMapIndex);
    if (lastString.startsWith(BASE64_SOURCEMAP_STARTS_WITH)) {
        code = code.slice(0, inlineSourceMapIndex);
        if (!map) {
            try {
                map = JSON.parse(base64ToMap(lastString.slice(BASE64_SOURCEMAP_STARTS_WITH.length)));
            }
            catch (e) {
                console.log(e);
            }
        }
    }
    return {
        code: code,
        map: map
    };
}
function transform(code, _a) {
    var _b = _a === void 0 ? {} : _a, map = _b.map, jsxFile = _b.jsxFile, jsFile = _b.jsFile, _c = _b.parser, parser = _c === void 0 ? parse : _c;
    if (typeof code === 'object') {
        map = map || code.map;
        code = code.code;
    }
    var jsxData = normaliseInput(code, map);
    var magicString = new MagicString__default['default'](jsxData.code);
    var ast;
    try {
        ast = parser(code);
    }
    catch (err) {
        err.message += " in file://" + jsxFile;
        throw err;
    }
    simple(ast, {
        JSXText: function (data) {
            var start = data.start, end = data.end, raw = data.raw;
            if (raw) {
                var keepRightSpace = jsxData.code[end] === '{';
                var keepLeftSpace = jsxData.code[start - 1] === '}';
                var targetValue = raw
                    .replace(/('|\\)/g, "\\$1")
                    .replace(/\n/g, '')
                    .replace(/(\s)+/g, ' ');
                if (!keepLeftSpace) {
                    targetValue = targetValue.replace(/^(\s)+/g, '');
                }
                if (!keepRightSpace) {
                    targetValue = targetValue.replace(/(\s)+$/g, '');
                }
                data.result = targetValue;
                magicString.overwrite(start, end, targetValue ? "'" + targetValue + "'" : '');
            }
        },
        JSXExpressionContainer: function (_a) {
            var start = _a.start, end = _a.end;
            magicString.remove(start, start + 1);
            magicString.remove(end - 1, end);
        },
        JSXFragment: function (_a) {
            var children = _a.children;
            var started = false;
            for (var i = 0; i < children.length; i++) {
                var _b = children[i], type = _b.type, start = _b.start, result = _b.result;
                if (type !== 'JSXText' || result) {
                    if (started) {
                        magicString.appendLeft(start, ',');
                    }
                    else {
                        started = true;
                    }
                }
            }
        },
        JSXOpeningFragment: function (_a) {
            var start = _a.start, end = _a.end;
            magicString.overwrite(start, end, '[');
        },
        JSXClosingFragment: function (_a) {
            var start = _a.start, end = _a.end;
            magicString.overwrite(start, end, ']');
        },
        JSXElement: function (_a) {
            var children = _a.children, openingElement = _a.openingElement;
            var childrenStarted = false;
            var lastEnd;
            for (var i = 0; i < children.length; i++) {
                var _b = children[i], type = _b.type, start = _b.start, end = _b.end, result = _b.result;
                lastEnd = end;
                if (type !== 'JSXText' || result) {
                    if (!childrenStarted) {
                        magicString.appendLeft(openingElement.end, ',children:[');
                        childrenStarted = true;
                    }
                    else {
                        magicString.appendLeft(start, ',');
                    }
                }
            }
            if (childrenStarted) {
                magicString.appendRight(lastEnd, ']');
            }
        },
        JSXOpeningElement: function (_a) {
            var start = _a.start, end = _a.end, name = _a.name, selfClosing = _a.selfClosing, attributes = _a.attributes;
            var fullName = name.type === 'JSXMemberExpression'
                ? name.object.name + "." + name.property.name
                : name.name || '';
            var stringSym = /[a-z]/.test(fullName[0]) ? "'" : '';
            magicString.overwrite(start, start + 1, '{type:');
            if (stringSym) {
                magicString.appendLeft(name.start, stringSym);
                magicString.appendLeft(name.end, stringSym);
            }
            var lastEnd = name.end;
            if (attributes) {
                for (var i = 0; i < attributes.length; i++) {
                    var attribute = attributes[i];
                    magicString.remove(lastEnd, attribute.start);
                    lastEnd = attribute.end;
                    if (!i) {
                        magicString.appendLeft(name.end, ',props:{');
                    }
                    else {
                        magicString.appendLeft(attribute.start - 1, ',');
                    }
                    if (i + 1 === attributes.length) {
                        magicString.appendLeft(attribute.end, '}');
                    }
                }
            }
            if (selfClosing) {
                magicString.overwrite(lastEnd, end, "}");
            }
            else {
                magicString.remove(lastEnd, end);
            }
        },
        JSXClosingElement: function (_a) {
            var start = _a.start, end = _a.end;
            magicString.overwrite(start, end, "}");
        },
        JSXAttribute: function (_a) {
            var name = _a.name, value = _a.value;
            var isNamespacedName = name.type === 'JSXNamespacedName';
            var namespacedNameType;
            if (isNamespacedName) {
                var namespace = name.namespace;
                name = name.name;
                namespacedNameType = namespace.name;
                magicString.overwrite(namespace.start, namespace.end + 1, '');
            }
            if (name.name.includes('-')) {
                magicString.overwrite(name.start, name.end, "'" + name.name + "'");
            }
            if (value) {
                if (value.type !== 'Literal' && namespacedNameType === 'get') {
                    magicString.overwrite(name.end, value.start, "(){return ");
                    magicString.appendLeft(name.start, 'get ');
                    magicString.appendLeft(value.end, '}');
                }
                else {
                    magicString.overwrite(name.end, value.start, ":");
                }
                if (value.type === 'Literal' && value.value) {
                    magicString.overwrite(value.start + 1, value.end - 1, value.value.replace(/\\/g, '\\\\'));
                }
            }
            else {
                magicString.appendLeft(name.end, ':true');
            }
        },
        JSXSpreadAttribute: function (_a) {
            var start = _a.start, end = _a.end;
            magicString.remove(start, start + 1);
            magicString.remove(end - 1, end);
        },
    });
    return {
        code: magicString.toString(),
        map: merge(jsxData.map, magicString.generateMap({
            file: jsFile,
            source: jsxFile,
            includeContent: true,
            hires: true
        }))
    };
}

var version = "1.3.2";

commander.program
    .version(version, '-v, --version');
commander.program
    .arguments('<jsx-file> [js-file]')
    .description('Converts <jsx-file> to <js-file>', {
    'jsx-file': 'Target file path, you want convert',
    'js-file': 'A path of the converted file',
})
    .option('-m, --map', 'Create map file')
    .option('-w, --watch', 'Watching of changes')
    .action(function (jsxFile, jsFile, _a) {
    if (jsFile === void 0) { jsFile = jsxFile.replace(/\.jsx$/, '.js'); }
    var map = _a.map, watch = _a.watch;
    function convert() {
        var data = transform(fs__default['default'].readFileSync(jsxFile, 'utf8'), { jsFile: jsFile, jsxFile: jsxFile });
        if (map) {
            fs__default['default'].writeFileSync(jsFile, data.code + ("\n//# sourceMappingURL=" + (jsFile.replace(/^(.*\/)?([^\/]+)$/, '$2') + '.map')));
            fs__default['default'].writeFileSync(jsFile + '.map', JSON.stringify(data.map));
        }
        else {
            fs__default['default'].writeFileSync(jsFile, data.code);
        }
        console.log('Successful build');
    }
    convert();
    if (watch) {
        fs__default['default'].watchFile(jsxFile, convert);
    }
});
commander.program
    .parse(process.argv);
